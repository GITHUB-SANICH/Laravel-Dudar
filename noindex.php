
	<?php
	echo '<hr><hr><br><h2>Модуль №16.1-4:  Создание проекта на Laravel и выгрузка на сервер
</h2>' . "<br>";

	echo '<hr><hr><br><h3>Back - #16.1 - Система_авторизации
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этом уроке реализуем функционал регистрации и авторизации пользователя. 
		В проекте уже имеется модель "User" и соответственно таблица с пользователями. В нее уже можно заносить зарегестрированных пользователей. 
		Задачи: нужно создать страницу регистрации, авторизации, личный кабинет пользователя, на страницах должны быть форммы. 

		Весь перечисленный функционал мы можем создать самостоятельно - через создание контроллеров, отслеживание адресов, создание шаблонов. 
		Однако под эти задачи уже имеются подготовленные шаблоны laravel для системы авторизации и регистрации.

		УСТАНОВКА ФУНКЦИОНАЛА ДЛЯ РЕГИСТРАЦИИ/АВТОРИЗАЦИИ
			Для этого понадобится прописать ряд команд в терминале:
				Установка библиотеки laravel\ui. 
				Очень простой каркас аутентификации, построенный на CSS-фреймворке Bootstrap. Он также позволяет выбрать между пресетами Vue и React.
					1) php composer.phar require laravel\ui	
				Установка библиотеки, на основе которой создаются шаблоны регистрации/авторизации. Знаний библиотеки в уроке не понадобится:
					Эта команда устанавливает зависомость в файле "package.json" (аналоге composer.json, но для клиентской части).
					2) php artisan ui vue --auth
						где, 
							vue		- база устанавливаемой библиотеки
							--auth	- уточнение об устанавливаемом шаблоне (система регистрации и авторизации)
				Установка библиотек, прописанных в файле "package.json".
					3) npm install - или npm i
				ВАЖНО! при выполнении комнады могут возникнуть ошибки, однако они не вилияют на работоспособность проекта. 
				Команда, компилирующая код из папки "resources" в папку "public". Это нужно, потому, что в папке "resources" появились файлы для работы функционала "vui":
					4) npm run dev
					
		ОБЗОР НОВЫХ ПАПОК/ФАЙЛОВ В ПРОЕКТЕ
			1) resources\views\auth
				Шаблоны с регистрацией, авторизацией, проверкой почты (последняя нам не понадобится - "verify.blade.php" - удалим ее).
			2) resources\views\home.blade.php
				Шаблон для отображения кабинета пользователя. Мы будем несколько менять (в основном) визуальную часть шаблонов. 
			3) layouts 
				Это аналог папки с файлом главной страници "app.blade.php", (уже меется main.blade.php). В него уже встраиваются остальные шаблоны. 
				Прежде чем удалить эти папку и файл - возмем из него некоторый код:
				а) <meta name="csrf-token" content="{{ csrf_token() }}">
					Это CSRF Token. Через этот токен во все формы на сайте встраивается специальный ключ. Он нужен для того, чтобы обезопасить передачу данных через формы. Например осуществить передачу дынных к передаваемым данным на сервер через форму. 
					В формах библиотеки laravel\html этот токен встроен по-умолчнию. Встроем этот тег в клавную страницу. 
				б) <script src="{{ asset('js/app.js') }}" defer></script>
					Подключение JS. Остальные части файла "app.blade.php" не нужны, так как шрифты и стили мы уже подключили. 
				в) Тег "@guest" с содержимым. 
					Этот тег является своего рода условием по отображению ссылок для авторизованных и не авторизованных пользователей. 
					Вставляем его с содержимым в место ссылок на главной странице. 
					Содержимое тега @guest:
						1) href="{{ route('login') }}"
							Псевдоним ссылки - в laravel можно дать ссылке псевдоним вместо определенного названия и вставлять его в куда нужно без необходимости повсеместного изменения. Псевдоимя присваивается методом "name" в в файле web.php.
							Теперь псевдоним является название ссылки. При этом саму ссылку можно менять в одном месте, при необходимости. 
							Пример: 
								Route::get('/', 'StaticController@index_metod')->name('home');
					Оставим в этом теге ссылки авторизации и регистрации для гостей: "/login", "/register". 
						Для авторизованных пользователй будет доступна ссылка на ЛК: 
						"<a href="/home">{{ Auth::user()->name }}</a>". 
						где,
							Auth::user()->name	- вызов имени авторизованного пользователя. 
				г) Кнопка-форма. 
					В форме нахдится пометка о "csrf" токеном и кнопка выхода из учетной записи:
						@csrf
						<button type="submit">Выйти</button>
				Теперь можно удалять папку "layouts". 
				
				ВАЖНО! В файле "web.php" имеется ошибка с классом "Auth". Ошибка не влечет ни каких проблем, но для ее исправления достаточно просто подключить класс к файлу:
					"use Illuminate\Support\Facades\Auth;". 

		ИЗМЕНЕНИЯ В ШАБЛОНЕ РЕГИСТРАЦИИ
			1) В случаи удаления файла "app.php" , при переходе на страницу регистрации должна появляться ошибка, из-за того, что встроенный шаблон не находится. Пропишем в шаблоне регистрации файл "main" и все заработает. Замену нужно произвести на страницах "register", "login", "home".
			2) В файлах добавим секцию заголовка, в контент добавим название заголовка и ссылку на главную страницу. 
			3) Поменяем форму регистрации ... формат формы будет классическим:
				а) Метод - post, action - /register. 
				б) Оставим в форме @csrf токен. 
				в) Добавим класс из предыдущих форм: "article-form".
				г) Добавляем поля, нужные для регистрации. 
				
				ВАЖНО! Пример реализации класса в laravel:
					class="form-control @error('email') is-invalid @enderror"
					где,
						form-control		- класс №1
						@error('email')	- условие ошибки
						is-invalid			- класс №2
						@enderror			- конец условия ошибки
				Т.е. при определенной ошибки выводится иной класс. 

				Ниже полей есть код выводящий сообщение при ошибке, но мы его написали в предыдущем модуле. 
				Пример кода по-умолчанию:
				@error('email')
					<span class="invalid-feedback" role="alert">
						<strong>{{ $message }}</strong>
					</span>
				@enderror
			
			4) В форме имеется поле для подтверждения пароля - оставим его и упростим.
			5) Кнопку отправки формы - тоже упростим. 
			6) Ошибки при заполнении полей выводятся на английском, но это испраивм в файле "lang\en\validation.php".
			7) Чтобы значение полей не сбрасывались при ошибках - в каждом поле в атребуте "value" вставим метод "old" с атребутом поля.
				Пример: 
					value="{{ old('email') }}"
			Заполняем форму и регистрируем пользователя. 
			Основной функционал уже прописан. В основном остается его реализовывать и верстать шаблоны. 

			ИЗМЕНЕНИЯ В ШАБЛОНЕ ЛИЧНОГО КАБИНЕТА
				1) Теперь при авторизации в шапке сайта отображается имя авторизхованного пользователя и кнопка выхода из учетной записи. В шаблоне остается только код с сообщением об успешной авторизации из сессии и названием страницы:
				Пример: 
					@section('content')
						<div class="block">
							<h1>Кабинет пользователя</h1>
							@if (session('status'))
								<div class="success-mess">
										{{ session('status') }}
								</div>
							@endif
						<p>Вы авторизованы</p>
						</div>
					@endsection
			
			ИЗМЕНЕНИЯ В ШАБЛОНЕ АВТОРИЗАЦИИ
				1) Теперь обработчик нахдится по ссылке action="/login". 
				2) В форме остаются поля почты, пароля и чекбоксом "запомнить пароль". 
					Логин: mail@mail.ru
					Пароль: qwerqwer
				3) Если нам нужно, чтобы кабинет пользователя открывался по ссылке "/user", а не "/home"/ Д
					а) Для этого нужно зайти в файл web.php и поменять в строке ссылку:
						Пример:
							Было:		Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home');
							Стало:	Route::get('/user', [App\Http\Controllers\HomeController::class, 'index'])->name('home');
					б) В "app\Providers\RouteServiceProvider.php" поменять константу, ведущую к кабинету пользователя:
						Пример:
							Было:		public const HOME = '/home';
							Стало:	public const HOME = '/user';
					в) И в "resources\views\layout\main.blade.php" поменять ссылку, ведущую в кабинет пользователя:
						Пример:
							Было:		<a href="/home">{{ Auth::user()->name }}</a>
							Стало:	<a href="/user">{{ Auth::user()->name }}</a>
					г) Кнопку по добавлению статей сделаем доступной только для авторизованных пользователей. 
				
		Остается только дописать стили для новыйх страниц. 
		ВАЖНО! ... но это не точно. Для корректного переноса CSS файлов из папки "resources" в папку "public" нужно прописать в файле "webpack.mix.js":
				Пример:
					Было:		.sass('resources/sass/app.scss', 'public/css');
					Стало:	.postCss('resources/css/app_dz.css', 'public/css');
			*/

			echo '<hr><hr><br><h3>Back - #16.2 - Статьи_в_личном_кабинете
			</h3><hr><hr>' . "<br>";
			/*Введение:
				На данный момент кабинет пользователя скуден и более того - сисьема добавления, вывода, показа статей имеет сеъездные ошибки. 
				Например удалять и изменять может любой пользователь - исправим это. 

			ВНЕСЕНИЕ ИЗМЕНЕНИЙ В ТАБЛИЦУ ЧЕРЕЗ МИГРАЦИИ
			ВАЖНО! В случаи изменения первоначального названия таблици дае после удаления и таблици и миграции - модели нужно дать понять с какой таблицей она работает. Для этого в моделе нужно прописать код. 
			Пример:
				"protected $table = "comments_article";"
				где, 
					$table					- обявление названия таблицы, которой привязана модель
					"comments_article"	- название таблицы, к которой привязана модель

				Стаьи не имеют автора - создадим миграцию, которая добавляет поле с пользователем для таблице 'Articles'.
				Это можно сделать через интерфейс PMA, но мы сделаем это черзе миграции. 
				Команда создания новой миграции для таблицы:
				Пример:
					php artisan make:migration add_new_field_to_articles
					где, 
						make:migration					- создание миграции
						add_new_field_to_articles	- название создаваемой миграции
				В файле миграции имееются как и в остальных миграциях методы "up()" и "down()". 
				Сейчас мы не будем создавать таблицу - поэтому соответственно в первом методу пропишем создание нового поля, а во втором его удаление. 
				Пример: 
					1) $table->integer('user_id');	-	integer - это тип вносимых данных в поле. Это будет Id автора статьи
					2) $table->dropColumn('user_id');
				Запускаем миграцию: php artisan migrate
				В созданных ячейках статей - внесем id уже созданного пользователя вручную. 

			Пример добавления статьи под новым пользователем:
				Для добавления имени автора статьи в самой статье - нужно в контроллере статей прописать ввод Id автора в методе занесения информации. 
				Пример: 
					$article->user_id = auth()->user()->id;
					где, 
						$article->user_id - обращение к полю в таблице модели
						auth()				- метод вывода информации доступную после авторизации
						user()				- метод вывода информации о пользователя
						id						- поле с Id авторизованного пользователя
			
			В новой добавленной статье - новым зарегестрированным и авторезованным пользователем отображается с Id другого пользователя.
			
			НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
				Для вывода автора статьи в самой статье - нужно настроить отношение между моделями. 
				Отношение выражается в соотношении информации таблиц моделей. 
				Это выражается в связях "один ко многим" или "один к одному". 
				Т.е. у одного автора может выводиться множество ссылок на статьи, но у одной статьи может выводиться только один автор. 
				Пропишем эти связи в моделях "Article" и "User". 				

				ВАЖНО! В примере выше Eloquent будет искать связь между user_id в модели Article и id в модели User. По умолчанию Eloquent определяет имя внешнего ключа по имени метода отношения, добавляя суффикс _id. Однако, если имя внешнего ключа модели Phone не user_id, передайте это имя вторым параметром в метод belongsTo():
				Пример связи моделей Article и User по схеме "один к одному":
					public function user(){
						return $this->belongsTo('App\Models\User', 'user_id');
					}
					где, 
						belongsTo				- метод указывающий ссылку по типу "один к одному"
						('App\Models\User')	- модель, с которой устанавливается связи и берется информация
						('user_id')				- внешний ключ модели

				ВАЖНО! Как и для метода hasOne()/belongsTo() вы можете указать внешний и локальный ключи, передав дополнительные параметры в метод hasMany():
				Пример связи модели User с Article по схеме "один ко многим":
					//метод вывода статей для одного пользователя
					public function articles(){
						return $this->hasMany('App\Models\Article', 'user_id');
					}
					где,
						hasMany						- метод выводящий ссылку по типу "один ко многим"
						('App\Models\Article')	- модель, с которой устанавливается связи и берется информация
						('user_id')					- внешний ключ модели
				
				ВАЖНО! Если связь прописывается в модуле таблицы со статьями - то прописывается связь "один к одному", так как у одной стаьи один автор. 
				При этом в связях "один к одному/один ко многим" первым выступает модуль в котором прописывается связь, в вторым число возможных связей.  
				Если у модуля User, прописывается сввязь например с кооментариями или статьями, то и в первом и во втором случаях это связи "один ко многим", так как у одного пользователя может быть мнодество статей и множество комментариев.
				А у одного комментария один автор и одна статья.  

				Когда связи установлены можно выводить информацию в статьях. 
				ВАЖНО! При наличии отношений между моделями - тип передачи данных в шаблона чреез класс "DB" будет выдавать ошибку:
					Поэтому при наличии этих отношений передавать информацию в шаблон через модель.
						Пример:
							Вариант с ошибкой:	$articles = DB::select('SELECT * FROM articles');
							Вариант без ошибки:	$articles	= Article::all();
				Пример вывода имени автора статьи в списке главной странице:
					<p><b>Автор: </b>{{$el->user->name}}</p>
					где,
						user	- метод, котоырй связует таблици статей и пользователей
						name	- имя пользователя (если честно ХЗ как laravel сам находит нужное имя)
			
			ВЫВОД СТАТЕЙ ПОЛЬЗОВАТЕЛЯ В КАБИНЕТЕ ПОЛЬЗОВАТЕЛЯ
			Для выворда статей пользователя в его личном кабинете нужно обратиться к контроллеру "HomeController" 
			(он отвечает за личный кабинет (ЛК)) - в нем есть метод "index", котоырй возвратщает шаблон ЛК. 
			Перед выводом шаблона в методе index пропишем получение данных о пользователе, чтобы выводились статьи пользователя:
				Пример:
					public function index()
						{
							//получение Id пользователя
							$user_id = auth()->user()->id;
							//вывод строк по Id пользователя	
							$user	= User::find($user_id);
							//передача в шаблон статей авторезованного пользователя
							return view('home')->with('articles', $user->articles);
						}
				
			В сам шаблон вставим цикл вывода статей и вставим в цикл имя автора статьи:
				Пример: 
					<p><b>Автор: </b> {{ $el->user->name }} </p><br>	- вывод имени автора
			Так же в качестве приветствия вставим имя пользователя и его почту:
				Пример:
					<p>Привет, {{ Auth::user()->name }}</p>
					<p>{{ Auth::user()->email }}</p>


			ИСПРАВЛЕНИЕ НЕДОЧЕТОВ В СИСТЕМЕ ПРОЕКТА ПО ДОСТУПУ ПОЛЬЗОВАТЕЛЙ
			1. Работа контроллера только при наличии авторизации
				На даный момент доступ к редактированию и удаленю статей имеет каждый пользователь и не только их автор. 
				Несмотря на то, что страница "/article/add" не отображается неаторизованному пользователю - он может ее вбить вручную и добавить запись. 
				Решается это просто - в контроллере ЛК есть конструктор, который проверяет пользовователей на авторизацию. 
				Если пользователь не авторизован, то laravel его переадресовывает автоматом на главную страницу либо на страницу регистрации.
				Пример:
					public function __construct(){
						$this->middleware('auth');
					}
				Вставим этот конструктор в контроллеро "ArticleController".
				Теперь при любом обращении к контроллеру - происходит редирект на страницу авторизации. 

				ВАЖНО! Laravel запоминает страницу, с которой пользователя перебросила на страницу авторизации. 
				После авторизации идет переброску на ту страницу, с которой произошел последний редирект на страницу авторизации.

				Но не на все методы контроллера должны распространятся правила проверки акторизации - например для прочтения статей. 
				Для этого нужно вносить исключения для некоторых методов - например для вывода статей и их прочтения. 
				Пример прописи методов, на которые проверка авторизации не распространяется:
					public function __construct(){
						$this->middleware('auth', ['except' => ['show']]);
					}
					где, 
						['except' => ]	- объявления списка методов исключений
						['show']			- метод, на который правило проверки авторизации не распространяется

			2. Отображение элементов при условии авторизации
					Для отображение функционала только при авторизации пользователя - контент нужно обрамить скобками - @auth @endauth. 
					Обрамим кнопки изменения и удаления статьи. 
					Пример:
						@auth
							<br><hr><br>
							<a href="/article/{{$article->id}}/edit">Редактровать статью</a><br><br>
							{!! Form::open(['method' => 'DELETE', 'action' => ['ArticlesController@destroy', $article->id]]) !!}
								{{ Form::submit('Удалить', ['class' => 'delete-button']) }}
							{!! Form::close() !!}
						@endauth
					Теперь при авторизации изменение и удаление статей становится доступным только после авторизации. 
			
			3. Отображение контента только для определенного пользователя
					Кнопки изменения и удаления статьи стали доступны только для всех авторизованных пользователй. 
					Но кнопки должны быть доступны только автора самой статьи. 
					Для этого в вывод статьи нужно прописывать еще одно условие поверх условия вывода контента только авторизованным пользователям. 
					Пример: 
						@auth
							@if(Auth::user()->id == $article->user_id)
								<br><hr><br>
								<a href="/article/{{$article->id}}/edit">Редактровать статью</a><br><br>
								{!! Form::open(['method' => 'DELETE', 'action' => ['ArticlesController@destroy', $article->id]]) !!}
									{{ Form::submit('Удалить', ['class' => 'delete-button']) }}
								{!! Form::close() !!}
							@endif
						@endauth
				Теперь кнопки изменения и удаления статей отображаются только у авторов статей. 
			
			4. Возможность редактирования чужого контената при переходе через адресную строку. 
					Сейчас если менять номер редактируемой статьи по сслыке "article/2/edit" - то для редактирования становятся доступны все статьи. 
					Для этого нужно внести дополнитльную проверку в мтеод редактирования статей контроллера "ArticleController" пользователя на авторство. 
					Для этого в методе "edid" - редактирование статей после вывода запроса поиска содержимого статьи -
					- нужно провести пользоватетя через проверку на авторство. 
					Пример: 
						//проверка на авторство
						if(auth()->user()->id != $article->user_id){
							return redirect('/')->with('error', 'Это не ваша статья');
						}
						где, 
							auth()->user()->id							- Id авпоризованного пользователя
							$article->user_id								- Id автора статьи 
							->with('error', 'Это не ваша статья');	- пепердача в шаблон сессии "error" с сообщением 'Это не ваша статья'
						Если Id авторизованного пользователя и автора стаьи неравны, то происходит редирект на главную страницу. 
						Тоже самое сделаем для метода удаления статьи. 
		*/

		echo '<hr><hr><br><h3>Back - #16.3 - Загрузка_изображений_через_форму
		</h3><hr><hr>' . "<br>";
		/*Введение:
			В ходе урока будет проработан функционал добавления, загрузки и отображения изображений в статьях. 
		
		ПОДГОТОВКА ФОРМЫ ДЛЯ ДОБАВЛЕНИЯ ИЗОБРАЖЕНИЯ
			Заходим в шаблон добавления статей "views\articles\create.blade.php" и добавляем в форму атребут "enctype" - он позволяет форме принимать файлы. Этот атребут имеет значение "multipart/form-data". Этот атребут считается частью HTML, а не Laravel. Выглядеть это будт так: 
			Пример:
				{!! Form::open(['class' => 'article-form', 'enctype' => 'multipart/form-data']) !!}
			
			И добавим в форму поле для добавления изображения:
			Пример:
				{{Form::label('main_image', 'Фото статьи')}}
				{{Form::file('main_image')}}
			Но сейчас сам функционал добавления не реализован. 

			Добавим дополнительное поле в таблицу articles для хранения названия изображения. Сделаем это через миграцию. 
			Команда:
				php artisan make:migration add_main_image_to_articles	- создание миграции
			В созданной миграции нужно убедиться, что работа ведется с таблицей "Articles". 
			Прописываем создание нового поля и запускаем миграцию:
				$table->string('image'); и $table->dropColumn('image');
		
		НАСТРОЙКА ФУНКЦИОНАЛА ПОЛУЧЕНИЯ ИЗОБРАЖЕНИЯ ЧЕРЕЗ ФОРМЫ И ЕГО ВЫВОД
			Данные формы принимает контроллер Articles-store - прописывать функционал приянтия картинки в этом методе.
			В проверке указываем строку:
				'main_image' => 'nullable|image|max:500'
				где,
					main_image	- название проверяемого поля в форме
					nullable		- дозволенность незаполнения поля
					image			- содержимым поля является изображение
					max:500		- максимальный размер изображения 500 кб. 
			
			Теперь паропишем функционал получения изображения из формы и загрузки его на сервер. 
			1. Функционал получения изображения:
				Мысль состаит в том, что при добавлении изображение должно иметь униклаьное название, которое наверняка не будет перезаписываться последующими добавляемыми изображениями. 
				Для реализации этой идее нужно: 
					а) принять название изображения от пользователя. 
					б) разделить его на название изображения и формат изображения. 
					в) добавить к названию изображения уникальный код (или время добавления) и прикрепить у к нему формат изображения. 
				Пример:
					if ($request->hasFile('main_image')) {
						$file = $request->file('main_image')->getClientOriginalName();
						$image_name_without_ext = pathinfo($file, PATHINFO_FILENAME);
						$ext = $request->file('main_image')->getClientOriginalExtension();
						$image_name = $image_name_without_ext."_".time().".".$ext;
						$request->file('main_image')->storeAs('public/img/articles', $image_name);
					}else{
						$image_name = 'noimage.jpg';
					}
				где,
					$request	- даныне получаемые пользователем
					hasFile	- метод проверки поля на наличие файла
					file('')	- метод принимающий из переменной $request (смотреть выше) файл. В методе указывается поле формы из которой принимается файл.
					getClientOriginalName	- метод отображения полного имени файла
					$image_name_without_ext	- переменная, хранящая в себе название изображения
					pathinfo	- метод, получающий путь к файлу, обрезая формат файла
					($file, PATHINFO_FILENAME) - $file - название файла, PATHINFO_FILENAME - условие обрезания названия файла (все кроме имени файла).
					$ext		- переменная, хранящая в себе формат изображения
					getClientOriginalExtension	- метод обрезающий название файла до формата формата. 
					$image_name	- переменная хранящая в себе измененное-уникальное название файла форматом
					$request->file('main_image')->storeAs('public/img/articles', $image_name); - строка сохранения/загрузки файла
					storeAs	- метод загрузки файла 
					public/img/articles				- путь загрузки файла
					$image_name							- имя файла, под которым он загружается на сервер
					$image_name = 'noimage.jpg';	- в случаи если фото не прикреплено, прикрепляется картинка по-умолчанию. Оно будет добавлено позже. 

				Когда проверка произведена - нужно добавить название картинки в БД. 
				Пример:
					$article->image = $image_name;
					где, 
						$article->image	- обращение к полю таблицы
						$image_name			- названеи картинки
			
			2. Связь между папками "public" и "storage".
				При добавлении статьи - название изображения в должном формате добавляется в БД. 
				Однако в нужную папку по адресу "public/storage/img/articles/" она не добавляется. 
				Дело в том, что при загрузки файла через метод "storeAs" 
				- он добавляется в папка "storage\app\public\img\articles\ckeditor_5_1655884019.png"
				Для того, чтобы картинка сохрянялась в папке "public/img/articles" - нужно связать ее с папкой "storage\app\public\img\articles\". 
				Для этого нужно в терминале прописать команду. 
				Пример: 
					php artisan storage:link
				Теперь в папке "public" появилась папка "/storage/img/articles/", в которую дублируюются все сачнные изображения.
				Теперь файлы будут попадать по-прежнему в папку "storage", но будут дублироваться и в папку "public/storage/img/articles/". 
		
			Настройка отображения картинок в статьях
			1. Настройка отображения изображений в статье
				Переходим в шаблон отображения статьи и прописываем там код вывода картинки:
				Пример: 
					<img src="/storage/img/articles/{{ $el->image }}" alt="">
					где, 
						/storage/img/articles/	- путь до картинки
						$el->image	- обращение к полю с названием картинки
				Чтобы картинки отображались и в статьях, которые добавлялись без присоединения картинки - добавим в БД к каждой из этих статей название картинки в тупую "noimage.php". 
				Внутрь проекта закидываем изображение "по-умолчанию" в папку "storage\app\public\img\articles". После оно перекидыватся в папку "public".
				В папку "public\storage\img\articles" изображение подгрузится автоматически из папки "storage" - сюда его закидывать не нужно. 
				Теперь картинки статей отображаются. 
			2. Пропишем стили для приемлемого отображения картинок в статьях
				Достаточно прописать:
					.articles .post img{
						width: 100%;
						margin-bottom: 10px;
					}
			Прописываем код вывода изображения так же в шаблонах "show" и "home". 
				
		НАСТРОЙКА РЕДАКТИРОВАНИЯ И УДАЛЕНИЯ СТАТЕЙ С КАРТИНКАМИ
			В шаблоне редактированиии страницы нехватает поля добавления файла - добавим его из шаблона добавления статьи.
			Так же добавим дополнительный атребут к форме:  'enctype' => 'multipart/form-data'
			В метод обновления статьи перенесем все проверки и функции по добавлению картинки как в меотде добавления статьи. 
			
			В чем будет отличаться логика от добавления картинки в методе "store":
			1. Если пользователь не загружает изображение то теперь нет смысла присваивать статье изображение по-умолчанию. 
				Т.е. условие отпадает:  else{$image_name = 'noimage.jpg';}
			2. Если пользователь действительно загружает новое изображение, то меняем поле в с картинкой в БД - иначе меняем. 
				При изменении картинки - предыдущее изображение нужно удалить. Удаление происходит через через обращение к классу Storage.
					Для его вызова класс нужно подключить: 
					use Illuminate\Support\Facades\Storage;
			3. Удаляем старое изображении при загрузки нового. 
			ВАЖНО! Для удаления старого файла в папке "storage" - нужно подключить класс "Storage", который работает с загружаемыми файлами.
				Пример: 
					Storage::delete('/storage/img/articles/'.$article->image);
					где, 
						Storage::delete			- обращение к статическому методу класса "Storage" по удаление содержимого в папке "storage".
						'/storage/img/articles'	- папка из которой производится удаление
						$article->image			- название картинки, котороу удаляется из папки
						('public/img/articles/'.$article->image)	- полный путь до картинки 
			4. Название стандартного изображения "noimage" удалять не нужно, если оно заменяется на новое изображение из офрмы. 	
				Для этого пропишем дополнительную проверку на наличие в порме названия стандартного изображения. 
				Пример: 
					if ($article->image != 'noimage.jpg')
					
				1) Т.е. прописываем условие изменения картинки - если поле формы не пустое - открываем условие перезаписи изображения. 
				2) При этом, если картинка не является стандартной, то удаляем предыдущую картнку в папке "storage" и заменяем ее той, что в форме.  
					Пример: 
						if($request->hasFile('main_image')){
							if ($article->image != 'noimage.jpg') {
								Storage::delete('public/img/articles/'.$article->image);
							}
							$article->image = $image_name;			
						}
						где, 
						if($request->hasFile('main_image')	- условие проверки поле формы на наличие файла
				
			ВАЖНО! При таком коде старая картинка удалять не будет. 
			
			5. Реализация удаление статьи вместе с ее картинкой
				Теперь вместе со всем содержимым статьи нужно удалять еще и картинку статьи. 
				Для этого обратимся к методу удаления ("destroy") в контроллере и прописываем удаление картинки - кроме картинки по-умолчанию.
				Пример: 				
					if ($article->image != 'noimage.jpg') {
						Storage::delete('public/img/articles/' . $article->image);
					}
				Этот код смотрели в предыдущем пункте. Если статья имеет своё - не стандартное изображение - оно удаляется. 

			*/
			echo '<hr><hr><br><h3>Back - #16.4 - Выгрузка_на_хостинг
			</h3><hr><hr>' . "<br>";
			/*Введение:
				В этом уроке мы выложим проект на удаленный сервер - хостинг. Принцип загрузки сайта на хостинг везде одинаков. 
				Сначала хостингом импортируется БД, далее идет выгрузка самого сайта, затем корректировкка некоторых настроек проекта на хостинге.
				
		ПЕРЕБРОСКА БД НА ХОСТИНГ
			Переброска БД на хостинг начинается с ее экспорта с локального сервера и последующим импортом на сайте хостинг провайдера. 
			... кароче сейчас (23.06.2022) я .тот урок проходить не буду, так как он не требуется для сдачи ДЗ и за не го придется платить)))
			*/