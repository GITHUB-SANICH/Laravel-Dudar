<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Шаблоны проектирования</title>
</head>

<body></body>
<header>
	Шапка сайта
</header>

<?php
echo '<hr><hr><br><h2>Модуль №8: MVC схема проектирования
</h2>' . "<br>";
echo '<hr><hr><br><h3>Back - #8.2 - Презентация</h3><hr><hr>' . "<br>";
/*Введение:
MVC расшифровывается как «Model-View-Controller» или же «Модель-Представление-Контроллер»
В модели MVC каждую составляющую можно разбить на отдельный элемент:
	● Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
	● Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения
	модели.
	● Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости
	изменений.

Если проще это схема подразумевает разделение кода на три составляющие:
	1) Визуальная часть. (HTML, вывод информации)						- (View)
	2) Функционал (Back, подключение к БД, работа на сервере)		- (Model)
	3) Интерпретирует действия пользователя (Back)						- (Controller)

Контролер являеться интерпритатором действий пользователя и посредником между остальными звеньями схемы MVC.
Оснавная работа будет производиться с в Viev и Model, а Controler практически не будет разбираться в модуле. 

Эта схема свойствена и другим языкам программирования. 
Если никаких изменений от БД не требуется, то  идет переключение на View минуя Model.

Ход взаимодействия файлов в схеме MVC:
а) пользователь переходит по ссылке -> подстраивание состояния контролера под действующую страницу
б) пользователь нажимает кнопку -> вызывается контролер
в) контрлер обращается к БД -> контролер обращается к файлу из модели (подключеие к БД)
г) в случаи успшного изменения модель передает информацию контролеру -> контролер дает информацию View
д) View передает информацию контролеру -> контролер пердает данные на браузер
е) измененные данные отображаются на экран

Почему это удобно?
В файлах с разделенной ответственностью проще находиться потенциальную ошибку. 
*/

echo '<hr><hr><br><h3>Back - #8.3 - Введение в MVC</h3><hr><hr>' . "<br>";
/*Введение:
В ходе урока будет построена общая структура схемы MVC. 
В которой будет прописано поведение схемы на текст введенный в адресной строке в классе App. 
В зависимости от полученных через АС данных, идет вызов контроллеров и их методов, вызывающих страницу на экран. 

Наличие на сайте системы MVC подразумевают использование в большом проекте с большим колличесвом папок, файлов. 
В маленьком проекте наличие MVC означает большое колличество папок не заполненных файлами. 
MVC это схема в которой с ходу сложно разобраться, поэто сложности объяснимы. 
Приступим:
Набор папок, нообходимых для построения схемы MVC:
1)  app		- папка, хронящая все файлы системы MVC.
		Это контроллеры, модели, доп. классы. 
2)  public	- папка, хранящая JS, CSS, index.html/index.php
		Это файлы, показываемые пользователю. 
3)  app/controllers 	- папка с контроллерами 
4)  app/models			- папка с моделями
5)  app/views			- папка с файлами, отображаемыми в браузерами (HTML)
6)	 app/core			- папка с базовыми классами  
7)  app/views/home	- папка с файлами, отображаемыми на главной странице
8)	 ../app/init.php	- файл с подключенными файлами с классами (каждый класс находится в своем файле)
9)	 core/App.php		- файл с базовым классом. Этот класс вызывается при заходе на сайт и отслеживает URL адрес, по которому мы перешли. 
10) core/Controller.php					- файл основной для всех контроллеров
11) app/controllers/Home.php			- файл контроллер, отвечающий за главную страницу. Это дочерний класс. Остальные дочерние классыотвечают за другие страницы. 
12) .htaccess								- файл настройки работы сервера в папке, в которой находится файл


1.	index.php - это основной файл, запускамый на сайте
	Подключим к нему файл 'init.php': 
		require_once '../app/init.php'; 
	В файле 'init.php' подключим класс, находящийся в папке 'core':
		core/App.php
			В классе пропишем конструктор. 
	В файле 'index.php' создадим объект от класса 'App'.
	Сейчас при вызове основгого файла index.php - вызывается и файл с необходимыми классами (init.php). 

2. Создадим основной файл для всех контроллеров с классом 'Controller' и подключим этот файл к 'init.php':
		require_once 'core/Controller.php';
	Создадим контроллер Home, отвечающего за главную страницу - он наследник главного контроллера Controller, как и остальные контроллеры - его тоже прикрепим к 'init.php':
		require_once 'app/controllers/Home.php';
	Создадим в контроллере Home функцию "index".

3. Класс "App"  - вызывается при заходе на страницу. 
	В нем указываются контроллеры/функции, вызываемые по-умолчанию при заходе на страницу. Или какие параметры были перезады через URL адресс. 
	Контроллер по-умолчанию это контроллер, вызываемый при отсутствии параметров , переданных через URL.	
	Пример контроллера по умолчанию: protected $controller = 'Home';
	Пример метода по умолчанию protected $method	= 'index'; Метод указан в контроллере "Home".
	Поле protected $params = [''];, хранящее данные, полученные из URL запроса. 

	Подведение итогов на середине видео:
		index.php		- это основной файл. В него подключен файл, хранящий различные файлы "init.php". Это файл вызывается методом по-умолчанию у каждого контроллера ("index"). 
		init.php			- файл, хранящий подключения нужных файлов (в основном классы), чтобы на основной странице не было полотна с десятков подключений.
		Controller.php - основной класс для всех контроллеров. Пока он пуст 
		У класса Controller (контроллер) есть дочерние классы - эти классы в зависимости от посещаемой страницы вызывают нужный HTML файл и показывают его пользоватесю.
			Home.php		- класс наследник главного контроллера, отвечает за вовод главной страницы. Другие дочерние классы отвечают за вывод других страницы. Предварительно связавшись с БД. Функция на которую ссылается класс и ведет на страницу. Пример "home/index" или "shope/index", где home и shope - классы, 
			а index - метод класса, вызывающий страницу. 
		App.php			- класс, отслеживающий URL адрес, по которому мы перешли. При переходе на клавную страниицу или отсутствующую страницу выводит главную страницу. Через 	обращение к контроллеру Home. А контроллер Home обращается к методу, выводящему страницу "view/home/index.php"
			Поле $params[] - это дополнительный параметр, который можно передать вместе с контроллером и его методом по вызову страницы. 
			Этот массив тоже передается в контроллер. Возможно это нужно для динамических страницы
	
	4. htaccess и App.
		Теперь посмотрим как в классе App получать данные из URL запроса.
		В конструкторе классс прописывается вызов метода, которая проверяет наличие в ссылке данных из GET запроса. И при его наличии выводить страницу с учетом GET запросса.
		Создадим в папке App файл ".htaccess", в котором находятся настройки сервера.
		
		Запретим пользователям переходить на папку app, так как она сделана для разработчиков: 
		Для этого в файле ".htaccess" пропишем:
			Option - Indexes
			Это сделает  папку App недоступной. Однако ".htaccess" работает корректно. При исправной работе ".htaccess" - сервер выдает "ошибку 500" или "forbidden". 
			Создадим такой же файл внутри папки "public".  
				Запишем в нем настройку: Option -MultiViews. Это означает, что к файлу можно обратиться без указания расширения (index).
				Запишем еще: RewriteEngine On - эта настройка отвечает за запуск движка
				Запишеми еще: RewriteBase /public/ - эта настройка отвечает за объявление главной страницы от которой идет работа с файлами. Обычно используется просто слэш "/" 
					То есть устанавливает базовый URL, после которого на этом этапе обработки и ваши правила преобразований работают только в оставшейся части. 
				Запишем еще: RewriteCond %{REQUEST_FILENAME} !-d - настройка для работы с файлами
				Запишем еще: RewriteCond %{REQUEST_FILENAME} !-f - настройка для работы с файлами, срабатывает при попадании не на ту папку. 
				Запишем еще: RewriteRule ^(.+)$ index.php?url=$1  - правило, переписывающее URL адрес страницы не отображая команду "?url=".
					По-другому говоря значение написанное после index.php - будет передано в URL адрес после "index.php"
	5. Функция отслеживания изменения в адрессной строке в классе App, вызываемом при открытии страницы:
					return explode('/', filter_var(	 
						rtrim($_GET['url'], '/'),
						FILTER_SANITIZE_STRING
					));	
		Подобное разделение длинных строк когда на несколько строк - принято по PSR стандартам. 
		Где, 
		return 		- возврат
		explode 		- функция разделения строки. Первый параметр разделяющий символ, а второй - разделяемая строка
		rtrim 		- функция убирающая символ в начале и в конце строки. Первый параметр это строка, второй параметр это исключаемый символ. 
		filter_var	- функция очищающая строку от лишний символов
				*/

	echo '<hr><hr><br><h3>Back - #8.4 - Создание контроллеров</h3><hr><hr>' . "<br>";
		/*Введение:
		В хооде видео мы научимся выбирать нужный контроллер и нужную функцию внтутри контроллера.
		В адресе в по порядку расположены: контроллер->метод->дополнительные параметры. 
		
		1. Определение контроллера:
			Для того, чтобы было понятно - какой элемент в адрессной строке является контроллером (и существует ли он вообще), а какой методом или параметром - нужно произвести проверки в файле, который первым принимает данные из адрессной строки (App.php). 
			
			В конструкторе класса App пропишем условие на проверку контроллера:
				if(file_exists('../app/controllers/'.ucfirst($url[0]).'php')){			//проверка на наличие контроллера с названием первого элемента в адресной строки после корневой папки. 
					$this->controller =  ucfirst($url[0]);										//если такой контроллер есть, то заменять контроллер по-умолчанию на контролер в вдресной строке.
					unset($url[0]);														 			//удаление первого значения массива (контроллера) - это нужно, так как дальше пойдут методы. 
				}
				require_once '../app/controllers/'.$this->controller.'.php';			//вызов нужного контролера

			где, 
			file_exists - проверка файла на наличие
			$this->controller =  ucfirst($url[0]);	 - замена контроллера по-умолчанию контроллером из адресной строки
			unset($url[0]); - удаление названия контроллера из доп. параметров, чтобы он не мешался отслеживанию метода
			require_once '../app/controllers/'.$this->controller.'.php';		//вызов нужного контролера, на который был заменен контроллер по-умолчанию

		2. Определение метода:
			Когда определились, что предлагаемый контроллер существует - нужно так же проверить есть ли у него предлагаемые методы: 
			Для определения метода сначала нужно создать объект на основе класса контроллера, чтобы после в через этот объект проверить наличие методов. 
			//Отслеживание метода
			$this->controller = new $this->controller;					//создание объекта на основе класса контроллера, дял поиска функций внутри его
			if (isset($url[1])) {												//при наличии второго параметра (метода ... могли вписать только один параметр) - то проверяем - метод ли это 
				if(method_exists($this->controller, $url[1])){			//проверка наличия метода внутри класса. Первый аргумент - проверяемый класс, второй аргумент - предполагаемый метод
				$this->method = $url[1];										//присвоение методу по-умолчанию значения второго параметра - это метод. 
				unset($url[1]);													//удаление второго значения массива (метода) - это нужно, так как дальше пойдут параметры. 
			}
		}
		После перезаписи метода и удаления его как элеменат массива - массив продолжит числиться с 3-го по индексу элемента.  Без удаления 
		
		3. Определение параметров: 
		После удаление первых двух элементов массива - в нем остаются только дополнительные параметры.
		Эти параметры тоже передаются в контроллер. 
		Но сначала нужно проверить оставшуюся часть массива на пустоту, и если массив не пуст, то обнулить индексы массива. Это нужно, так как дальнейшего отделения индексов массива на классы/методы/параметры не будет - остались только параметры, тогда с ними удобнее работать в классической форме массива. 
		
		//Обнуление индексов оставшихся значений
		$this->params = $url ? array_values($url) : [];			//проверка массива на пустоту. При заполненности - обнулить текущие индексы. При пустоте - присвоить пустое значение. 

		//Отправка параметров
		//функция вызова метода (с отправкой параметров в него) внутри указанного класса. Первый атребут - класс и метод (в массиве). Второй - параметры, пересылаемые в метод. 
		call_user_func_array([$this->controller, $this->method], $this->params);		 
		
		Сейчас базавая схема MVC построена - идет отслеживание URL адресов и идет вызовов нужных контроллеров и нужных функций. 
		Параметры передаются в функции, но еще не принимаются. 
		Чтобы их принять: в методах контроллеров нужно прописать число принимаемых параметров и их значения.
		Пример: 
				public function index($pervParametr = '', $vtorParametr = ''){
					echo 'Contact index: <br>'.'Первый параметр: '. $pervParametr.'<br>Второй параметр: '. $vtorParametr;
				}
		где, 
		$pervParametr, $vtorParametr принимаемый параметр метода (первый и второй - название произвольные).
		'' - значение параметра по-умолчанию. Более заданного числа параметров не принимается. 
	
		*/

		echo '<hr><hr><br><h3>Back - #8.5 - Модели и представления</h3><hr><hr>' . "<br>";
		/*Введение:
		В ходе урока будет разобрана работа с моделями и представлениями данных. 
		В моделях записывается весь функционал. 
		
		1. Созданеи модели.
		Создадим модель "User" в папке "models". 
		В этой моле будет происходить основная работа над пользователем (добавление в БД/вывод информации о пользователе и т.п.). 
		ВАЖНО! Файл "Controllers.php' нужно переместить в папку "core". Его наличие в папке "controllers" было ошибкой - так как при вводе АС Сontroller - пользователь мог выйти на информацию внутри главного родительского контролелра. И он не подразумевает функционала, обеспечивающего пользователю доступ к страницам сатйа. Путь к файлу тоже везде должен быть изменен.
		
		2. Обеспечение доступа к модели для вех контроллеров. 
			Создадим в классе Controllers метод: protected "model". Этот метод будет передаваться по-наследству классам.  
				Метод принимает в аргумент название модели, от которой нужно получить объект. 
				Пример: 
					class Controller{												//класс - родитель контроллеров
						protected function model($model){					//метод запроса к модели (для всех наследников+)				
							require_once '/app/models/'.$model.'.php';	//подключение модели, к от которой ожидается принятие объекта	
							return new $model();									//возврат объекта на основе класса - модели. Скобки не обязательны. 
						} 
					}
			Этот мув обеспечил доступ к модулю длоя блока с модулями для всех контроллеров. 
		
		3. Обращение к модели (обращение к БД  через модель). 
			Когда доступа к модулям через родтеля получен - можно обращаться к ним. 
			В контрллере Home обратимся через метод index к модулю User.
			Если понадобится вывести всю информацию о пользователе, то в модуле User понадобилось бы вызвать класс по соединению с БД и через запрос ввывести данные пользователя, чье имя совпадает с именем в контроллере Home ($name). В контроллере значение поля берется из адресной строки.
				Пример обращения к модели, отвечающего за вывод информации о пользователе:
						public function index($name = ''){ //при переходе на страницу функция принимает доп.параметр
							$user = $this->model("User");	//функция model прописана в родителе контроллеров. В функцию вносится название, вызываемой модели. Она подключается в родителе и на ее основе создается объект. В переменную $user помещается объект вызываемой модели.
							$user->name = $name;				//обращение объекта модели к ее полю
							//Если нужно вызвать только имя, то достаточно прописать тоько: 
							//echo '<br>Имя пользователя: <b>'.$user->name.'</b><br>';	//вывод на экран надписи, которая отсутствует в контроллерах, метода. Т.е. является параметром. 
							//Вызов все информации по пользователю подразумевал бы обращение к мтоду модели пользователя:
							//$user->getInfo();
						} 
				Пример обращения модели к БД за полной информацией о подльзователе:
							public function getInfo(){
								//Требования по выводу информации
								//Подключение к классу с подключением к БД (шаблон одиночка).  
								//Составленеи запроса
								//вывод информации через echo
							}

		4. Работа с представлениями (передача данных из модели)
			Предыдущий способ вывода информации не удобен. Удобнее выводить сразу большие HTML файлы и подставлять в них полученные значения. 
			В родительском контроллере создадим функцию с модефикатором доступа для наследников. 
			Пример:
			//функция вызова страницы на экран
			protected function view($view, $data = []){	//метод запроса к модели (для всех наследников+). Первый аргумент страницы, второй - доп.параметры в форме массива. Пустопо-умалчанию. 
				require_once '../app/views/'.$view.'.php';//вывод на экран файла по адресу. $view = 'home/index' - эот аргументы вводимые при вызове метода в контроллере "Home". 
			} 
			Наследники вызывают этот метод для вызова нужной страницы на экран с передачей для нее данных. 
			Пример: 
				$this->view('home/index', 
					['name' => $user->name, 
					'test' => 'Massege test']); //обращение к функции вызова страницы для вызова на экран. Первый аргумент - адрес файла. Второй - массив с доп.параметрами . 

			Итого:
			MVC разделяет код на категории (шаблоны). 
			Папка "view" - хранит визуальную часть проекта
			Папка "models" - хранит весь функционал 
			Парка "controllers" - хранит классы, связющие видимую часть сайта с функционалом
			Файл "App" - файл для отслеживания всех URL адресов
			Файл "Controller" - файл с классом родителем всех контроллеров
			Схема построения сайта MVC нужны для построения крупный динамических сайтов.
		*/


?>
<footer></footer> 
</body>

</html>