<?php
	echo '<hr><hr><br><h2>Тема: Создание RESTful API на Laravel.
</h2>' . "<br>";

	echo '<hr><hr><br><h3>Урок - #1 - Введение
	</h3><hr><hr>' . "<br>";
	/*Введение:
	Ссылка:
	https://www.youtube.com/watch?v=avgI61lPZ7c&list=PLtHO7nOKfHGaWhgndBeHQFm6bYZ7ROuVe&index=12

	API - интерфейс взаимодействия программ. 
	REST - это архитектурный стиль взаимодействия серверной и клиентской частей через API. 

	В ходе урока установим OpenServer, Composer, Laravel, Postman.

	*/

	echo '<hr><hr><br><h3>Урок - #2 - Подключение базы данных
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этой части урока мы импортируем и подключим базу данных, и настроим получение JSON данных от сервера
	1. Создание БД, создание контроллера и модели
		Из ссылки гитхаба берем БД и импортируем ее. 
		Меняем название БД в файле .en: меняем с "laravel-basics" на "lesson-api".
		Создаем контроллер и модель к импортированной таблице. 
		Пример:
			protected $table = 'country_lang';

			protected $fillable = [
				'id',
				'alias',
				'name',
				'name_en'
			];

		В моделе создадим два поля: указывающее на принадлежность к таблице и поле с массивом, указывающее на поля, которые будут заполняться в БД. 

	2. Роуты, наполнение контроллера
		В этой части урока мы импортируем и подключим базу данных, и настроим получение JSON данных от сервера
		В роутах пропишем маршрут к мтодам модели
			Роут находится в папке "routes\api.php".
			Route::get('/сountry', [App\Http\Controllers\CountryController::class, 'сountry']);

		К контроллеру подключим модель:
			use App\Models\Country;
		Пропишщем в контроллере метод "сountry", возвратщающий записи из таблици импортированной "country_lang".
		Пример:
			public function country(){
				return dd(response()->json(Country::get(), 200));
			}
		
		Включаем сервер командой php artisan serve

	3. Настройка rouat находится в файле "app\Providers\RouteServiceProvider". Там же прописывается префикс к ссылке, котоырй не указывается в файле "routes\api.php".
		Ссылка "http://127.0.0.1:8000/api/country". 
		
		Вставим ее в Postman, чтобы увидеть ее в формате JSON. 
	*/

	echo '<hr><hr><br><h3>Урок - #3 - Добавление записи
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этой части урока мы рассмотрим как можно добавлять данные в базу данных

		Запишем роут для вывода записи по ID:
			Route::post('/country/{id}', [App\Http\Controllers\CountryController::class, 'createById']);
		Добавим в контроллер метод поиска записи с передаваемым id:
			public function createById($id){
				return response()->json(Country::find($id), 200);
			}

		Запишем роут для записи в БД:
			Route::post('/country', [App\Http\Controllers\CountryController::class, 'countrySave']);

		Добавим в контроллер метод записи данных в БД:
			public function countrySave(Request $request){
				$country = Country::create($request->all());
				return response()->json($country, 201);
			}

		При вызове урла (POST запросом) в Postman пропишем в интерфейсе поля в парметрами:
			alias=>ru+
			name=>test
			name_en=>test-en

		BИ еще ...  Предварительно перед отправкой запроса в Postman нужно в модель добавить поле о недобавлении полей. 
		Добавление полей может вызвать ошибку, а может и нет:
			"created_at" и "updated_at". Поле public $timestamps = false;

		Итоговая ссылка для добавления записи:
			http://127.0.0.1:8000/api/country?alias=ru+&name=test&name_en=test-en
		
	*/
	echo '<hr><hr><br><h3>Урок - #4 - Редактирование и удаление
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этой части урока мы рассмотрим как редактировать и удалять данные из базы

		1. Создание роутов
			Как и в предыдущих роликах - начнем с создания роутов. 
				Route::put('/country/{country}', [App\Http\Controllers\CountryController::class, 'countryEdit']);
				Route::delete('/country/delete/{id}', [App\Http\Controllers\CountryController::class, 'countryDelete']);

		2. Описание мтоедов
			Метод обновления записи:
				public function countryEdit(Request $request, Country $country){
					$country->update($request->all());
					return response()->json($country, 200);
				}
				где,
					Request $request 									- объект запроса
					Country $country									- объект модели 
					$country->update($request->all());			- обновление записи через внесение всех данных из запроса
					return response()->json($country, 200);	- возвратщение отвента в формате JSON с объектом модели и ответом 200

			Вызовем запись через №5 через метод GET: 
				http://127.0.0.1:8000/api/country/5
			Попробуем эту запись отредактировать методом PUT: 
				http://127.0.0.1:8000/api/country/5?name=NOАнтигуа и Барбуда&name_en=NOAntigua and Barbuda
			Запись изменена, при том не обязательно вписывать все поля для изменения. 
			
			Метод удаления записи:
				public function countryDelete(Request $request, Country $country){
					$country->delete();
					return response()->json('', 204);
				}
				где,
					Request $request 									- объект запроса
					Country $country									- объект модели 
					$country->delete();								- обновление записи через внесение всех данных из запроса
					return response()->json('', 204);			- возвратщение ответа в формате JSON(пустотой json c ответом 204(успешное удаление)).
						
			Вызовем запись через №253 через метод DELETE: 
				http://127.0.0.1:8000/api/country/253
			Если боратиться к этой записи после удаления, то будет возвратщаться пустой JSON c кодом 200 - после исправим это. 

			Комментарии в идео:
			-Автор, все супер  - спасибо! но есть проблема.   такой API  не работает, если к нему обращаться через  Ajax с Клиента, срабатывает CORS защита.   Если бы Автор нашел в себе силы Дополнить код Анти-Cors-ом,   было бы еще круче.   Постмен, конечно, работает с таким АПИ, а вот реальный Клиент... увы

			-Vit Che хорошее замечание! Суть проблемы в том что Postman это не браузер и он не обращает внимания на межсайтовый скрипт. А вот браузеры должны его блокировать, т.к это будет дыркой в их безопастности. Я дополню комментарий строками кода которые решат эту проблему, для отдельного видео будет инфы на минуту и смысла в таком коротком видосе нет:
				Vit Che В файле config/cors.php установите нижнюю строку в значение True, если я верно помню параметр называется support_credential. И если мне не изменяет память то в ларавел 7 это будет работать из коробки, без установки дополнений. Сейчас проверить это не могу, т.к свет выключили)

			- @user-ni5jy4dh2b  ,  с утра делал API (Client - Laravel & Ajax,    API - Laravel_7 & Mongodb) и все "ломалось" на cors, перепробовал все, на Postman работает, а в браузере - нет. А Ваш код, почему-то заработал сразу, без доп настроек. Супер! ещё раз Спасибо!
	*/

	echo '<hr><hr><br><h3>Урок - #5 - Валидация входящих данных
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этой части урока мы рассмотрим как сделать вальдацию входящих данных	

		1. Валидация на проверку существующей щаписи
		Сначала рассмотрим ситуацию, когда запрашивается несуществующий ID:
			//работающий, но не верный код вывода ошибки
			$country = Country::find($id);
			if (is_null($country)) {
				return response()->json(['error' => true, 'message' => 'no found'], 404);	
			}

		2. Валидация методов редактирования и удаления на проверку существующей щаписи
			В роутах вместо {cpuntry} будем передавать {id}
			Перепишем методы удаления и обновления записей на монер проверки метода вывода записи:
				public function countryDelete(Request $request, $id){
					$country = Country::find($id);
					if (is_null($country)) {
						return response()->json(['error' => true, 'message' => 'no found'], 404);	
					}

					$country->delete();
					return response()->json('', 204);
				}
		
		3. Валидация данных пользователя
			Даже если данные от пользователя будут получены и они будут пустыми - они все ровно обработаются. 
			Например пользователь передает пустоту - значи запись будет перетерта. 
			Исправим это:
				Подключим в фассад валидатор: 
					use Illuminate\Support\Facades\Validator;

				$rules = [
					'alias' => 'required|min:2|max:2',
					'name' => 'required|min:3',
					'name_en' => 'required|min:3'
				];

				$validator = Validator::make($request->all(), $rules);
				if ($validator->fails()) {
					return response()->json($validator->errors(), 400);
				}

				где, 
					$rules - массив с требованиями к полям JSON
					$validator - поле хранящее рещультат валидации
					Validator - фассад, проверяющий полученные данные от пользователя на требования в поле $rules
					$validator->fails() - проверка на наличие ошибок
					$validator->errors() - метод вывода ошибок в поле JSON

				ВНИМАНИЕ! Этот метод проверки данных работает, но удобнее испоьзовать метод "validate". 
				При невыполнении условия проверки полученных от пользователя полей - код дыльше не выполняется.
				Пример: 
					$this->validate($request, [
						'title' => 'required', 
						'anons' => 'required',
						'text' => 'required'
					]);
				
	*/

	echo '<hr><hr><br><h3>Урок - #6 - JWT авторизация
	</h3><hr><hr>' . "<br>";
	/*Введение:
		В этом уроке я расскажу как защитить ваше приложение при помощи токена JWT от Tymon.
		В этом уроке разберем расмотрим как организавать доступ к API через JWT аунтефикацию. 
		
		Виды токенов (разберем только JWT):
			Токены доступа (JWT) — это токены, с помощью которых можно получить доступ к защищенным ресурсам. Они короткоживущие, но многоразовые. В них может содержаться дополнительная информация, напрмер, время жизни или IP-адрес, откуда идет запрос. Все зависит от желания разработчика.
			Рефреш токен (RT) — эти токены выполняют только одну специфичную задачу — получение нового токена доступа. И на этот раз без сервера авторизации не обойтись. Они долгоживущие, но одноразовые.

		Веб-токен JSON, или JWT (произносится "jot"), представляет собой стандартизированный, в некоторых случаях подписанный и/или зашифрованный формат упаковки данных, который используется для безопасной передачи информации между двумя сторонами.
		
		Структура JWT
		JWT состоит из трех частей: 
			а) Заголовок "header", 
			б) Полезные данные "payload", 
			в) Подпись "signature".
		Первые два елемента являюстя JSON объектами, а третий вычисляется на базе первых двух частей и секретного ключа и зависит от выбранного алгаритма шифрования.
		Секретный ключ, необходимый для третьего елемента "signature" хранится на сервере. 

		Первые два объекта токена можно прочитать без труда. Изменять их нельзя - иначе весь токен не пройдет проверку на сервере.
		ТЕОРИЯ:
		СОЗДАНИЕ JWT:
		1. Шаг 1. Создаем HEADER
			Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись. 
			Хедер — это тоже JSON объект, который выглядит следующим образом:
				header = { "alg": "HS256", "typ": "JWT"}
				где,
					typ => тип JWT
						typ - это дополнительные свойства, например, тип содержимого, хотя это редко требуется (не обязательынй параметр).
					alg => алгоритм хеширования
						Есть два алгоритм ахеширования
						а) HS256 и б) RS256.
					Но в некоторых случаях подпись и шифрование могут отсутствовать. Обычно это происходит, когда JWT является частью некоторой уже зашифрованной структуры данных.
				
		Шаг 2. Создаем PAYLOAD
			Payload — Полезные данные – часть токена, в которой размещается вся необходимая пользовательская информация. Эти данные также называют JWT-claims (заявки).
			Как и заголовок, полезная нагрузка представляет собой обычный объект JSON. Здесь ни одно поле не является обязательным.
			В примере, который рассматриваем мы, сервер аутентификации создает JWT с информацией об id пользователя — userId.
				payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }

			Существует список (в примере список не полный) стандартных заявок для JWT payload — вот некоторые из них:
				iss (issuer) — определяет приложение, из которого отправляется токен. (издатель токена)
				sub (subject) — определяет тему токена. (описываемый объект)
				exp (expiration time) — время жизни токена. (дата истечения срока действия)
			Эти поля могут быть полезными при создании JWT, но они не являются обязательными

		Шаг 3. Создаем SIGNATURE
		JSON web token в сериализованной форме – это строка следующего формата:
		Пример:
			[ Header ].[ Payload ].[ Signature ]

		Подпись вычисляется с использование следующего псевдо-кода:
			const SECRET_KEY = 'cAtwa1kkEy'
			const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
			const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
		Алгоритм base64url кодирует хедер и payload, созданные на 1 и 2 шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.
			// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
			// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
			// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM

		Шаг 4. Теперь объединим все три JWT компонента вместе
			Теперь, когда у нас есть все три составляющих, мы можем создать наш JWT. Это довольно просто, мы соединяем все полученные элементы в строку через точку.
				const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature)
				// JWT Token
				// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
			Теперь сервер аутентификации может слать пользователю JWT.
		
		Шаг 5. Проверка JWT
			В нашем простом примере из 3 участников мы используем JWT, который подписан с помощью HS256 алгоритма и только сервер аутентификации и сервер приложения знают секретный ключ.
			Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к JWT, что в шаге 3. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит JWT валидный, т.е. пришел от проверенного источника.
			
			ПРАКТИКА:
			Все команды, рекомендации и шаги взяты из документации и ролика на ютубе.
				1. Установка библиотеки для кодирования и декодирования JWT
					Обычно для кодирования и декадирования JWT используются фреймворки и библиотеки. Поэтому установим библиотеку "timon". 
					Учтановим ее через composer-команду предворительно поднавшись на папку выше, где находится composer-phar:
						composer require tymon/jwt-auth
					Команда подключения настроек к библиотеке:
						php artisan vendor:publish
						Вбираем провайдер: Tymon\JWTAuth\Providers\LaravelServiceProvider

				2. Настройка времени жизни токена
					Настройка времени жизни токена:	
					Файл появится в папке: config\jwt.php
					В файле будет множество настроек, но большинство из них прописывается в файле ".env". 
					Изменим время жизни токена в файле jwt.php =>  'ttl' => env('JWT_TTL', 60), => 60 на 1440
					Перейдем в файл .env и пропишем ключ в нем: 
						JWT_TTL=1440

				3. Генерация секретного ключа
					Команда генерации секретного ключа:
						php artisan jwt:secret
					Ключ сгенерировался в файле ".env":
						JWT_SECRET=0FVivfIjLSMnIruYPqr9fN5YTK5XcuYrnKoKEPqxnlivqcZ2K8fFmhURRyebmxvu

				4. Настройка авторизации 
					В уроке требуется установить нативную авторизацию laravel, но она у нас уже есть со всеми миграциями с курса "laravel с нуля". 
					Тоже касается модулей nod.js
					МИграция таблицы Users тоже уже есть
					Авторизуем нового пользователя

				5. Интеграция JWT в пользовательскую модель User
					В файл "laravel\app\Models\User.php" подключим контракт или интерфейс модели "User":
						"use Tymon\JWTAuth\Contracts\JWTSubject;" 
					Имплементируем контракт к модели:
						User extends Authenticatable implements JWTSubject
					Добавим в модель User метод возвратщения ключа:
						public function getJWTIdentifier()
						{
							return $this->getKey();
						}
					Добавим в модель User метод возвратщения пользовательских данных:
						public function getJWTCustomClaims()
						{
							return [];
						}

				6. Смена API драйвера
					В файле "laravel\config\auth.php" найдем секцию с гардами.
					В гарде 'api' проставлен драйвер "token" - меняем его на "jwt":
					'api' => [
						'driver' => 'jwt',
						'provider' => 'users',
						'hash' => false,
					],

				7. Отделение логику web части приложения от api
					Скопируем контроллер "app\Http\Controllers\Controller.php" в папку "laravel\app\Http\Controllers\Api\Controller.php", 
					который будет дополнять остальные контроллеры, использующие API.
					Пропишем в файле контсруктор с методом переключения драйвера по-умолчанию "web" на "api":
						public function __construct()
						{
							//auth()->setDefaultDriver('api');

						}

					Перенесем контроллер "CountryController.php" в папку "\Api\CountryController.php", поправим пути

				7. Создадим логин-контроллер
					Команда:
						php artisan make:controller Api\Auth\LoginController
					В контроллере создадим метод login(), который будет проверять ЛП пользователя на совпадение и возвратщать сообщение об ошибке - либо вернет токен:
						public function login(Request $request){
							$creds = $request->only(['email', 'password']);
							if (!$token = Auth::attempt($creds)) {
								return response()->json(['error' => true, 'message' => 'Incorect Login/Password'], '401');
							}
							return response()->json(['token' => $token]);
						}

				8. Пропишем в роуте новый путь для авторизации. 
					Роут авторизации пользователя:
						Route::post('/login', [App\Http\Controllers\Api\Auth\LoginController::class, 'login']);
					Проверяем ошибки с пространством имен и ввыдим ссылку в Postman:
						http://127.0.0.1:8000/api/login?email=alex@mail.ru&password=alex
					Приходит ошибка:
						{
							"error": true,
							"message": "Incorect Login/Password"
						}
					
				И ХЗ в ченм там ошибка.
				Тем не менее - продолжим.
				9. Проверка доступа перед обращению к методам
					Перепишем предыдущие роуты, так как уонтроллер поменял место.
					Чтобы только авторизованные пользователи могли получать данные с сервера - пропишем перед выполнением методов в таблице "CountryController" проверку:
						try {
							Auth::guard('api')->check();
						} catch (\Tymon\JWTAuth\Exceptions\UserNotDefinedException $e) {
							return response()->json(['error' => true, 'message' => $e->getMessage()], '401');
						}
						
					При попытке вывести запись без токена - выводится ошибка.
					Ссылка:
					http://127.0.0.1:8000/api/country
					
		

			

	*/

	echo '<hr><hr><br><h3>Урок - #7 - 
	</h3><hr><hr>' . "<br>";
	/*Введение:

	*/